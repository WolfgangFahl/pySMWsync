{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pySMWSync API Documentation","text":""},{"location":"#smwsync.mapping","title":"<code>mapping</code>","text":"<p>Created on 2023-03-03</p> <p>@author: wf</p>"},{"location":"#smwsync.mapping.Mapping","title":"<code>Mapping</code>","text":"<p>a mapping for properties</p> Source code in <code>smwsync/mapping.py</code> <pre><code>class Mapping:\n    \"\"\"\n    a mapping for properties\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        constructor\n        \"\"\"\n        self.map_by_topic = {}\n\n    def fromYaml(self, yaml_path: str):\n        \"\"\"\n        initialize me from the given yaml_path\n\n        Args:\n            yaml_path(str): the path to the yaml file\n        \"\"\"\n        # Read YAML file\n        with open(yaml_path, \"r\") as yaml_file:\n            self.map_list = yaml.safe_load(yaml_file)\n        for map_record in self.map_list:\n            topic_map = TopicMapping(map_record[\"topic\"])\n            for propm_record in map_record[\"prop_list\"]:\n                topic_map.add_mapping4record(propm_record)\n            self.map_by_topic[topic_map.topic_name] = topic_map\n        pass\n\n    def toYaml(self, yaml_path: str):\n        \"\"\"\n        store me to the given yaml_path\n\n        Args:\n            yaml_path(str): the path to the yaml file\n        \"\"\"\n        map_list = []\n        for tm in self.map_by_topic.values():\n            map_list.append(tm.asdict())\n        with open(yaml_path, \"w\") as yaml_file:\n            yaml.dump(map_list, yaml_file, sort_keys=False)\n</code></pre>"},{"location":"#smwsync.mapping.Mapping.__init__","title":"<code>__init__()</code>","text":"<p>constructor</p> Source code in <code>smwsync/mapping.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    constructor\n    \"\"\"\n    self.map_by_topic = {}\n</code></pre>"},{"location":"#smwsync.mapping.Mapping.fromYaml","title":"<code>fromYaml(yaml_path)</code>","text":"<p>initialize me from the given yaml_path</p> <p>Parameters:</p> Name Type Description Default <code>yaml_path(str)</code> <p>the path to the yaml file</p> required Source code in <code>smwsync/mapping.py</code> <pre><code>def fromYaml(self, yaml_path: str):\n    \"\"\"\n    initialize me from the given yaml_path\n\n    Args:\n        yaml_path(str): the path to the yaml file\n    \"\"\"\n    # Read YAML file\n    with open(yaml_path, \"r\") as yaml_file:\n        self.map_list = yaml.safe_load(yaml_file)\n    for map_record in self.map_list:\n        topic_map = TopicMapping(map_record[\"topic\"])\n        for propm_record in map_record[\"prop_list\"]:\n            topic_map.add_mapping4record(propm_record)\n        self.map_by_topic[topic_map.topic_name] = topic_map\n    pass\n</code></pre>"},{"location":"#smwsync.mapping.Mapping.toYaml","title":"<code>toYaml(yaml_path)</code>","text":"<p>store me to the given yaml_path</p> <p>Parameters:</p> Name Type Description Default <code>yaml_path(str)</code> <p>the path to the yaml file</p> required Source code in <code>smwsync/mapping.py</code> <pre><code>def toYaml(self, yaml_path: str):\n    \"\"\"\n    store me to the given yaml_path\n\n    Args:\n        yaml_path(str): the path to the yaml file\n    \"\"\"\n    map_list = []\n    for tm in self.map_by_topic.values():\n        map_list.append(tm.asdict())\n    with open(yaml_path, \"w\") as yaml_file:\n        yaml.dump(map_list, yaml_file, sort_keys=False)\n</code></pre>"},{"location":"#smwsync.mapping.TopicMapping","title":"<code>TopicMapping</code>","text":"<p>a property mapping for a given topic</p> Source code in <code>smwsync/mapping.py</code> <pre><code>class TopicMapping:\n    \"\"\"\n    a property mapping for a given topic\n    \"\"\"\n\n    def __init__(self, topic_name: str):\n        \"\"\"\n        initialize this topic mapping\n        \"\"\"\n        self.topic_name = topic_name\n        self.prop_by_arg = {}\n        self.prop_by_smw_prop = {}\n        self.prop_by_pid = {}\n\n    def __repr__(self):\n        \"\"\"\n        return my representation\n        \"\"\"\n        tm_dict = self.asdict()\n        tm_text = str(tm_dict)\n        return tm_text\n\n    def asdict(self):\n        prop_list = []\n        for pm in self.prop_by_smw_prop.values():\n            pm_record = dataclasses.asdict(pm)\n            prop_list.append(pm_record)\n        tm_dict = {\"topic\": self.topic_name, \"prop_list\": prop_list}\n        return tm_dict\n\n    def add_mapping4record(self, propm_record: dict) -&gt; PropMapping:\n        \"\"\"\n        add a property map record to the mapping\n\n        Args:\n            propm_record(dict): the record to instantiate the PropMapping from\n\n        Returns:\n            PropMapping: the property Mapping created and added\n        \"\"\"\n        propm = None\n        try:\n            propm = dacite.from_dict(data_class=PropMapping, data=propm_record)\n            self.add_mapping(propm)\n        except Exception as ex:\n            print(\n                f\"Warning property mapping {propm_record} could not be added: {str(ex)}\"\n            )\n            pass\n        return propm\n\n    def add_mapping(self, propm: PropMapping):\n        \"\"\"\n        add a property Mapping\n        Args:\n            propm:PropMapping\n        \"\"\"\n        if propm.arg:\n            self.prop_by_arg[propm.arg] = propm\n        self.prop_by_smw_prop[propm.smw_prop] = propm\n        if propm.pid:\n            self.prop_by_pid[propm.pid] = propm\n\n    def getPkSMWPropMap(self, pk: str) -&gt; PropMapping:\n        pm = None\n        if pk == \"qid\":\n            if not pk in self.prop_by_pid:\n                raise Exception(\n                    f\"primary key arg {pk} of topic {self.topic_name}  has no mapping\"\n                )\n            pm = self.prop_by_pid[pk]\n        return pm\n\n    def getPmForArg(self, arg: str) -&gt; PropMapping:\n        if not arg in self.prop_by_arg:\n            raise Exception(\n                f\"property arg {arg} of topic {self.topic_name}  has no mapping\"\n            )\n        pm = self.prop_by_arg[arg]\n        return pm\n</code></pre>"},{"location":"#smwsync.mapping.TopicMapping.__init__","title":"<code>__init__(topic_name)</code>","text":"<p>initialize this topic mapping</p> Source code in <code>smwsync/mapping.py</code> <pre><code>def __init__(self, topic_name: str):\n    \"\"\"\n    initialize this topic mapping\n    \"\"\"\n    self.topic_name = topic_name\n    self.prop_by_arg = {}\n    self.prop_by_smw_prop = {}\n    self.prop_by_pid = {}\n</code></pre>"},{"location":"#smwsync.mapping.TopicMapping.__repr__","title":"<code>__repr__()</code>","text":"<p>return my representation</p> Source code in <code>smwsync/mapping.py</code> <pre><code>def __repr__(self):\n    \"\"\"\n    return my representation\n    \"\"\"\n    tm_dict = self.asdict()\n    tm_text = str(tm_dict)\n    return tm_text\n</code></pre>"},{"location":"#smwsync.mapping.TopicMapping.add_mapping","title":"<code>add_mapping(propm)</code>","text":"<p>add a property Mapping Args:     propm:PropMapping</p> Source code in <code>smwsync/mapping.py</code> <pre><code>def add_mapping(self, propm: PropMapping):\n    \"\"\"\n    add a property Mapping\n    Args:\n        propm:PropMapping\n    \"\"\"\n    if propm.arg:\n        self.prop_by_arg[propm.arg] = propm\n    self.prop_by_smw_prop[propm.smw_prop] = propm\n    if propm.pid:\n        self.prop_by_pid[propm.pid] = propm\n</code></pre>"},{"location":"#smwsync.mapping.TopicMapping.add_mapping4record","title":"<code>add_mapping4record(propm_record)</code>","text":"<p>add a property map record to the mapping</p> <p>Parameters:</p> Name Type Description Default <code>propm_record(dict)</code> <p>the record to instantiate the PropMapping from</p> required <p>Returns:</p> Name Type Description <code>PropMapping</code> <code>PropMapping</code> <p>the property Mapping created and added</p> Source code in <code>smwsync/mapping.py</code> <pre><code>def add_mapping4record(self, propm_record: dict) -&gt; PropMapping:\n    \"\"\"\n    add a property map record to the mapping\n\n    Args:\n        propm_record(dict): the record to instantiate the PropMapping from\n\n    Returns:\n        PropMapping: the property Mapping created and added\n    \"\"\"\n    propm = None\n    try:\n        propm = dacite.from_dict(data_class=PropMapping, data=propm_record)\n        self.add_mapping(propm)\n    except Exception as ex:\n        print(\n            f\"Warning property mapping {propm_record} could not be added: {str(ex)}\"\n        )\n        pass\n    return propm\n</code></pre>"},{"location":"#smwsync.synccmd","title":"<code>synccmd</code>","text":"<p>Created on 2023-03-03</p> <p>@author: wf</p>"},{"location":"#smwsync.synccmd.SyncCmd","title":"<code>SyncCmd</code>","text":"<p>Command line for synching</p> Source code in <code>smwsync/synccmd.py</code> <pre><code>class SyncCmd:\n    \"\"\"\n    Command line for synching\n    \"\"\"\n\n    def __init__(\n        self,\n        wikiId: str = \"ceur-ws\",\n        context_name: str = \"CrSchema\",\n        endpoint_name: str = \"wikidata\",\n        verbose: bool = False,\n        progress: bool = False,\n        dry: bool = True,\n        debug: bool = False,\n    ):\n        \"\"\"\n        Constructor\n\n        Args:\n            wikiId(str): my wiki Id\n            topic(str): the topic to sync\n            context_name(str): the name of the context\n            dry(bool): if True do not execute commands put display them\n            debug(bool): if True switch debugging on\n        \"\"\"\n        colorama_init()\n        self.lang = \"en\"\n        self.wikiId = wikiId\n        self.debug = debug\n        self.progress = progress\n        self.verbose = verbose\n        self.dry = dry\n        self.smwAccess = SMWAccess(wikiId)\n        self.context_name = context_name\n        self.mw_contexts = self.smwAccess.getMwContexts()\n        if not context_name in self.mw_contexts:\n            raise Exception(\n                f\"context {context_name} not available in SMW wiki {wikiId}\"\n            )\n        self.mw_context = self.mw_contexts[context_name]\n        self.context, self.error, self.errMsg = Context.fromWikiContext(\n            self.mw_context, debug=self.debug\n        )\n        self.endpoints = EndpointManager.getEndpoints(lang=\"sparql\")\n        self.endpointConf = self.endpoints.get(endpoint_name)\n        self.sparql = SPARQL(self.endpointConf.endpoint)\n\n    @classmethod\n    def fromArgs(self, args) -&gt; \"SyncCmd\":\n        \"\"\"\n        create a sync command for the given command line arguments\n\n        Args:\n            args(Object): command line arguments\n        \"\"\"\n        syncCmd = SyncCmd(\n            wikiId=args.target,\n            context_name=args.context,\n            endpoint_name=args.endpoint,\n            verbose=args.verbose,\n            progress=args.progress,\n            dry=args.dry,\n            debug=args.debug,\n        )\n        return syncCmd\n\n    @classmethod\n    def getArgParser(cls) -&gt; ArgumentParser:\n        \"\"\"\n        Setup command line argument parser\n\n        Returns:\n            ArgumentParser: the argument parser\n        \"\"\"\n        parser = ArgumentParser(\n            description=Version.full_description,\n            formatter_class=RawDescriptionHelpFormatter,\n        )\n        parser.add_argument(\n            \"-a\",\n            \"--about\",\n            help=\"show about info [default: %(default)s]\",\n            action=\"store_true\",\n        )\n        parser.add_argument(\n            \"--context\",\n            default=\"CrSchema\",\n            help=\"context to generate from [default: %(default)s]\",\n        )\n        parser.add_argument(\n            \"-cpm\", \"--createPropertyMap\", help=\"create the yaml property map\"\n        )\n        parser.add_argument(\n            \"-d\",\n            \"--debug\",\n            dest=\"debug\",\n            action=\"store_true\",\n            help=\"show debug info [default: %(default)s]\",\n        )\n        parser.add_argument(\n            \"--dry\",\n            action=\"store_true\",\n            help=\"dry run only - do not execute wikiedit commands but just display them\",\n        )\n        parser.add_argument(\n            \"-e\",\n            \"--endpoint\",\n            default=\"wikidata\",\n            help=\"the SPARQL endpoint to be used [default: %(default)s]\",\n        )\n        parser.add_argument(\"--progress\", action=\"store_true\", help=\"show progress bar\")\n        parser.add_argument(\"-p\", \"--props\", help=\"properties to sync\", nargs=\"+\")\n        parser.add_argument(\n            \"--proplist\", action=\"store_true\", help=\"show the properties\"\n        )\n        parser.add_argument(\"-pm\", \"--propertyMap\", help=\"the yaml property map\")\n        parser.add_argument(\n            \"-pk\",\n            \"--primaryKey\",\n            help=\"primary Key [default: %(default)s]\",\n            default=\"qid\",\n        )\n        parser.add_argument(\n            \"-pkv\", \"--primaryKeyValues\", help=\"primary Key Values\", nargs=\"+\"\n        )\n        parser.add_argument(\n            \"-t\",\n            \"--target\",\n            default=\"ceur-ws\",\n            help=\"wikiId of the target wiki [default: %(default)s]\",\n        )\n        parser.add_argument(\n            \"-u\", \"--update\", action=\"store_true\", help=\"update the local cache\"\n        )\n        parser.add_argument(\n            \"--topic\",\n            help=\"the topic to work with [default: %(default)s]\",\n            default=\"Scholar\",\n        )\n        parser.add_argument(\n            \"--verbose\", action=\"store_true\", help=\"show verbose edit details\"\n        )\n        parser.add_argument(\n            \"-V\", \"--version\", action=\"version\", version=Version.version_msg\n        )\n        return parser\n\n    def getTopic(self, topic_name: str):\n        \"\"\"\n        get the topic for the given topic name\n\n        Args:\n            topic_name(str): the name of the topic to get the properties for\n        \"\"\"\n        if not topic_name in self.context.topics:\n            raise Exception(\n                f\"topic {topic_name} is not in context {self.context.name} in wiki {self.wikiId}\"\n            )\n        topic = self.context.topics[topic_name]\n        return topic\n\n    def getCacheRoot(self, cache_root: str = None) -&gt; str:\n        \"\"\"\n        get the cache_root for the the given cache_root\n\n        Args:\n            cache_root(str): root of the cache_path - if None set to $HOME/.smwsync\n        Returns:\n            str: the cache root\n        \"\"\"\n        if cache_root is None:\n            home = str(Path.home())\n            cache_root = f\"{home}/.smwsync\"\n        return cache_root\n\n    def getCachePath(self, cache_root: str = None) -&gt; str:\n        \"\"\"\n        get the cache_path for the the given cache_root\n\n        Args:\n            cache_root(str): root of the cache_path - if None set to $HOME/.smwsync\n        Returns:\n            str: the cache path for my wikiId and context's name\n        \"\"\"\n        cache_root = self.getCacheRoot(cache_root)\n        cache_path = f\"{cache_root}/{self.wikiId}/{self.context.name}\"\n        os.makedirs(cache_path, exist_ok=True)\n        return cache_path\n\n    def getMapping(self, cache_root: str = None) -&gt; Mapping:\n        \"\"\"\n        get the mapping for the given cache_root\n\n        Args:\n            cache_root(str): root of the cache_path - if None set to $HOME/.smwsync\n        \"\"\"\n        mapping = Mapping()\n        cache_root = self.getCacheRoot(cache_root)\n        yaml_path = f\"{cache_root}/{self.context.name}_wikidata_map.yaml\"\n        mapping.fromYaml(yaml_path)\n        return mapping\n\n    def createMapping(self) -&gt; Mapping:\n        \"\"\"\n        create a mapping for my context\n        \"\"\"\n        mapping = Mapping()\n        for topic_name, topic in self.context.topics.items():\n            topic_map = TopicMapping(topic_name)\n            for prop_name, _prop in topic.properties.items():\n                pm = PropMapping(smw_prop=prop_name, arg=prop_name, pid=\"P?\")\n                topic_map.add_mapping(pm)\n            mapping.map_by_topic[topic_map.topic_name] = topic_map\n        return mapping\n\n    def color_msg(self, color, msg: str):\n        \"\"\"\n        print a colored message\n\n        Args:\n            color(Fore): the color to use\n            msg(str): the message to print\n        \"\"\"\n        print(f\"{color}{msg}{Style.RESET_ALL}\")\n\n    def updateItemCache(self, topic_name: str, cache_path: str = None) -&gt; str:\n        \"\"\"\n        update the item cache\n\n        for the given topic name and cache_path\n\n        Args:\n            topic_name(str): the name of the topic\n            cache_path(str): the path to the cache - if None .smwsync in the home directory is used\n\n        Returns:\n            str: the path to the json file where the data is cached\n\n        \"\"\"\n        topic = self.getTopic(topic_name)\n        ask_query = topic.askQuery(listLimit=5000)\n        items = self.smwAccess.smw.query(ask_query)\n        cache_path = self.getCachePath(cache_path)\n        json_path = f\"{cache_path}/{topic_name}.json\"\n        with open(json_path, \"w\", encoding=\"utf-8\") as json_file:\n            json.dump(items, json_file, ensure_ascii=False, default=str, indent=2)\n        return json_path, items\n\n    def readItemsFromCache(self, topic_name, cache_path: str = None):\n        \"\"\"\n        read the items back from cache\n        \"\"\"\n        cache_path = self.getCachePath(cache_path)\n        json_path = f\"{cache_path}/{topic_name}.json\"\n        with open(json_path, \"r\") as json_file:\n            items = json.load(json_file)\n        return items\n\n    def showProperties(self, topic: Topic):\n        \"\"\"\n        show the properties for the given Topic\n\n        Args:\n            topic(Topic): the topic to show the properties for\n        \"\"\"\n        if not topic.name in self.mapping.map_by_topic:\n            raise Exception(\n                f\"missing wikidata mapping for {topic.name} - you might want to add it to the yaml file for {self.context.name}\"\n            )\n        tm = self.mapping.map_by_topic[topic.name]\n        for prop_name, prop in topic.properties.items():\n            if prop_name in tm.prop_by_smw_prop:\n                pm = tm.prop_by_smw_prop[prop_name]\n                info = f\"{pm.arg}: {pm.pid_label} ({pm.pid}) \u2192 {prop.name}\"\n                print(f\"{info}\")\n            # else:\n            # info=f\"{prop_name}:{prop} \u274c - missing wikidata map entry\"\n            pass\n\n    def getValue(self, pk: str, pkValue: str, pid: str):\n        \"\"\"\n        get the value for the given primary key and the given property id\n        \"\"\"\n        value = None\n        if pk == \"qid\":\n            if pid == \"description\" or pid == \"label\":\n                value = None\n                try:\n                    label, description = WikidataItem.getLabelAndDescription(\n                        self.sparql, itemId=pkValue, lang=self.lang\n                    )\n                    if pid == \"description\":\n                        value = description\n                    else:\n                        value = label\n                    pass\n                except Exception as ex:\n                    # make sure we only ignore \"failed\"\n                    if not \"failed\" in str(ex):\n                        raise ex\n            else:\n                sparql_query = f\"\"\"SELECT * {{ \n  wd:{pkValue} wdt:{pid} ?value . \n}}\"\"\"\n                # see https://www.wikidata.org/wiki/Help:Ranking\n                # sparql_query=f\"\"\"SELECT ?value {{\n                #  wd:{pkValue} p:{pid} ?st .\n                #  ?st ps:P569 ?value .\n                # ?st wikibase:rank wikibase:PreferredRank\n                # }}\"\"\"\n\n                records = self.sparql.queryAsListOfDicts(sparql_query)\n                if len(records) &gt;= 1:\n                    record = records[0]\n                    value = record[\"value\"]\n                    if isinstance(value, str):\n                        value = re.sub(\n                            r\"http://www.wikidata.org/entity/(.*)\", r\"\\1\", value\n                        )\n                    else:\n                        value = str(value)\n        return value\n\n    def filterItems(self, items: list, pk_prop: str, pk_values: list) -&gt; list:\n        \"\"\"\n        filter the given list of items by SMW records having primary key property values\n        in the given pk_values list\n\n        Args:\n            items(list): the list of records to filter\n            pk_prop(str): the primary key property\n            pk_values(list): the list of primary key values\n        \"\"\"\n        if pk_values is None:\n            return items\n        sync_items = []\n        for item_record in items:\n            if pk_prop in item_record:\n                item_pk_value = item_record[pk_prop]\n                if item_pk_value in pk_values:\n                    sync_items.append(item_record)\n        return sync_items\n\n    def sync(self, topic: Topic, pk: str, pk_values: list, prop_arglist: list):\n        \"\"\"\n        synchronize the items for the given topic, the properties as specified by the prop_arglist\n        the given primary key pk and the filter values pkValues\n\n        Args:\n            topic(Topic): the topic / class /entityType\n            pk(str): the primary key to use\n            pk_values(list): a list of primaryKeyValues to filter for\n            prop_arglist(list): the argument names for properties to be handled\n\n        \"\"\"\n        tm = self.mapping.map_by_topic[topic.name]\n        items_dict = self.readItemsFromCache(topic.name)\n        pk_map = tm.getPkSMWPropMap(pk)\n        sync_items = self.filterItems(\n            items=items_dict.values(), pk_prop=pk_map.smw_prop, pk_values=pk_values\n        )\n        self.color_msg(\n            Fore.BLUE, f\"{len(sync_items)} {tm.topic_name} items to sync ...\"\n        )\n        wikipush = WikiPush(None, self.wikiId, debug=self.debug, verbose=self.verbose)\n        if self.progress:\n            t = tqdm(total=len(prop_arglist) * len(sync_items))\n        else:\n            t = None\n        for arg in prop_arglist:\n            pm = tm.getPmForArg(arg)\n            for sync_item in sync_items:\n                pk_value = sync_item[pk_map.smw_prop]\n                wd_value = self.getValue(pk, pk_value, pm.pid)\n                if wd_value is None:\n                    wd_value = \"\"\n                page_title = sync_item[tm.topic_name]\n                msg = f\"updating {page_title} {pm.smw_prop} to {wd_value} from wikidata {pk_value}\"\n                if self.verbose:\n                    self.color_msg(Fore.BLUE, msg)\n                cmd = f\"\"\"wikiedit -t {self.wikiId} -p \"{page_title}\" --template {tm.topic_name} --property {pm.smw_prop} --value \"{wd_value}\" -f\"\"\"\n                if self.dry:\n                    print(cmd)\n                if t is not None:\n                    t.set_description(f\"{page_title}\u2192{pm.smw_prop}\")\n                wikipush.edit_wikison(\n                    page_titles=[page_title],\n                    entity_type_name=tm.topic_name,\n                    property_name=pm.smw_prop,\n                    value=wd_value,\n                    force=not self.dry,\n                )\n                if t is not None:\n                    t.update()\n            pass\n\n    def main(self, args):\n        \"\"\"\n        command line handling\n        \"\"\"\n        if args.about:\n            print(Version.description)\n            print(f\"see {Version.doc_url}\")\n            webbrowser.open(Version.doc_url)\n        elif args.createPropertyMap:\n            mapping = self.createMapping()\n            mapping.toYaml(args.createPropertyMap)\n        else:\n            self.mapping = self.getMapping()\n            topic = self.getTopic(topic_name=args.topic)\n            if args.proplist:\n                self.showProperties(topic=topic)\n            if args.update:\n                self.color_msg(\n                    Fore.BLUE,\n                    f\"updating cache for {self.context.name}:{topic.name} from wiki {self.wikiId} ...\",\n                )\n                json_path, items = self.updateItemCache(topic.name)\n                self.color_msg(\n                    Fore.BLUE, f\"stored {len(items)} {topic.name} items to {json_path}\"\n                )\n            if args.props:\n                self.sync(\n                    topic=topic,\n                    pk=args.primaryKey,\n                    pk_values=args.primaryKeyValues,\n                    prop_arglist=args.props,\n                )\n</code></pre>"},{"location":"#smwsync.synccmd.SyncCmd.__init__","title":"<code>__init__(wikiId='ceur-ws', context_name='CrSchema', endpoint_name='wikidata', verbose=False, progress=False, dry=True, debug=False)</code>","text":"<p>Constructor</p> <p>Parameters:</p> Name Type Description Default <code>wikiId(str)</code> <p>my wiki Id</p> required <code>topic(str)</code> <p>the topic to sync</p> required <code>context_name(str)</code> <p>the name of the context</p> required <code>dry(bool)</code> <p>if True do not execute commands put display them</p> required <code>debug(bool)</code> <p>if True switch debugging on</p> required Source code in <code>smwsync/synccmd.py</code> <pre><code>def __init__(\n    self,\n    wikiId: str = \"ceur-ws\",\n    context_name: str = \"CrSchema\",\n    endpoint_name: str = \"wikidata\",\n    verbose: bool = False,\n    progress: bool = False,\n    dry: bool = True,\n    debug: bool = False,\n):\n    \"\"\"\n    Constructor\n\n    Args:\n        wikiId(str): my wiki Id\n        topic(str): the topic to sync\n        context_name(str): the name of the context\n        dry(bool): if True do not execute commands put display them\n        debug(bool): if True switch debugging on\n    \"\"\"\n    colorama_init()\n    self.lang = \"en\"\n    self.wikiId = wikiId\n    self.debug = debug\n    self.progress = progress\n    self.verbose = verbose\n    self.dry = dry\n    self.smwAccess = SMWAccess(wikiId)\n    self.context_name = context_name\n    self.mw_contexts = self.smwAccess.getMwContexts()\n    if not context_name in self.mw_contexts:\n        raise Exception(\n            f\"context {context_name} not available in SMW wiki {wikiId}\"\n        )\n    self.mw_context = self.mw_contexts[context_name]\n    self.context, self.error, self.errMsg = Context.fromWikiContext(\n        self.mw_context, debug=self.debug\n    )\n    self.endpoints = EndpointManager.getEndpoints(lang=\"sparql\")\n    self.endpointConf = self.endpoints.get(endpoint_name)\n    self.sparql = SPARQL(self.endpointConf.endpoint)\n</code></pre>"},{"location":"#smwsync.synccmd.SyncCmd.color_msg","title":"<code>color_msg(color, msg)</code>","text":"<p>print a colored message</p> <p>Parameters:</p> Name Type Description Default <code>color(Fore)</code> <p>the color to use</p> required <code>msg(str)</code> <p>the message to print</p> required Source code in <code>smwsync/synccmd.py</code> <pre><code>def color_msg(self, color, msg: str):\n    \"\"\"\n    print a colored message\n\n    Args:\n        color(Fore): the color to use\n        msg(str): the message to print\n    \"\"\"\n    print(f\"{color}{msg}{Style.RESET_ALL}\")\n</code></pre>"},{"location":"#smwsync.synccmd.SyncCmd.createMapping","title":"<code>createMapping()</code>","text":"<p>create a mapping for my context</p> Source code in <code>smwsync/synccmd.py</code> <pre><code>def createMapping(self) -&gt; Mapping:\n    \"\"\"\n    create a mapping for my context\n    \"\"\"\n    mapping = Mapping()\n    for topic_name, topic in self.context.topics.items():\n        topic_map = TopicMapping(topic_name)\n        for prop_name, _prop in topic.properties.items():\n            pm = PropMapping(smw_prop=prop_name, arg=prop_name, pid=\"P?\")\n            topic_map.add_mapping(pm)\n        mapping.map_by_topic[topic_map.topic_name] = topic_map\n    return mapping\n</code></pre>"},{"location":"#smwsync.synccmd.SyncCmd.filterItems","title":"<code>filterItems(items, pk_prop, pk_values)</code>","text":"<p>filter the given list of items by SMW records having primary key property values in the given pk_values list</p> <p>Parameters:</p> Name Type Description Default <code>items(list)</code> <p>the list of records to filter</p> required <code>pk_prop(str)</code> <p>the primary key property</p> required <code>pk_values(list)</code> <p>the list of primary key values</p> required Source code in <code>smwsync/synccmd.py</code> <pre><code>def filterItems(self, items: list, pk_prop: str, pk_values: list) -&gt; list:\n    \"\"\"\n    filter the given list of items by SMW records having primary key property values\n    in the given pk_values list\n\n    Args:\n        items(list): the list of records to filter\n        pk_prop(str): the primary key property\n        pk_values(list): the list of primary key values\n    \"\"\"\n    if pk_values is None:\n        return items\n    sync_items = []\n    for item_record in items:\n        if pk_prop in item_record:\n            item_pk_value = item_record[pk_prop]\n            if item_pk_value in pk_values:\n                sync_items.append(item_record)\n    return sync_items\n</code></pre>"},{"location":"#smwsync.synccmd.SyncCmd.fromArgs","title":"<code>fromArgs(args)</code>  <code>classmethod</code>","text":"<p>create a sync command for the given command line arguments</p> <p>Parameters:</p> Name Type Description Default <code>args(Object)</code> <p>command line arguments</p> required Source code in <code>smwsync/synccmd.py</code> <pre><code>@classmethod\ndef fromArgs(self, args) -&gt; \"SyncCmd\":\n    \"\"\"\n    create a sync command for the given command line arguments\n\n    Args:\n        args(Object): command line arguments\n    \"\"\"\n    syncCmd = SyncCmd(\n        wikiId=args.target,\n        context_name=args.context,\n        endpoint_name=args.endpoint,\n        verbose=args.verbose,\n        progress=args.progress,\n        dry=args.dry,\n        debug=args.debug,\n    )\n    return syncCmd\n</code></pre>"},{"location":"#smwsync.synccmd.SyncCmd.getArgParser","title":"<code>getArgParser()</code>  <code>classmethod</code>","text":"<p>Setup command line argument parser</p> <p>Returns:</p> Name Type Description <code>ArgumentParser</code> <code>ArgumentParser</code> <p>the argument parser</p> Source code in <code>smwsync/synccmd.py</code> <pre><code>@classmethod\ndef getArgParser(cls) -&gt; ArgumentParser:\n    \"\"\"\n    Setup command line argument parser\n\n    Returns:\n        ArgumentParser: the argument parser\n    \"\"\"\n    parser = ArgumentParser(\n        description=Version.full_description,\n        formatter_class=RawDescriptionHelpFormatter,\n    )\n    parser.add_argument(\n        \"-a\",\n        \"--about\",\n        help=\"show about info [default: %(default)s]\",\n        action=\"store_true\",\n    )\n    parser.add_argument(\n        \"--context\",\n        default=\"CrSchema\",\n        help=\"context to generate from [default: %(default)s]\",\n    )\n    parser.add_argument(\n        \"-cpm\", \"--createPropertyMap\", help=\"create the yaml property map\"\n    )\n    parser.add_argument(\n        \"-d\",\n        \"--debug\",\n        dest=\"debug\",\n        action=\"store_true\",\n        help=\"show debug info [default: %(default)s]\",\n    )\n    parser.add_argument(\n        \"--dry\",\n        action=\"store_true\",\n        help=\"dry run only - do not execute wikiedit commands but just display them\",\n    )\n    parser.add_argument(\n        \"-e\",\n        \"--endpoint\",\n        default=\"wikidata\",\n        help=\"the SPARQL endpoint to be used [default: %(default)s]\",\n    )\n    parser.add_argument(\"--progress\", action=\"store_true\", help=\"show progress bar\")\n    parser.add_argument(\"-p\", \"--props\", help=\"properties to sync\", nargs=\"+\")\n    parser.add_argument(\n        \"--proplist\", action=\"store_true\", help=\"show the properties\"\n    )\n    parser.add_argument(\"-pm\", \"--propertyMap\", help=\"the yaml property map\")\n    parser.add_argument(\n        \"-pk\",\n        \"--primaryKey\",\n        help=\"primary Key [default: %(default)s]\",\n        default=\"qid\",\n    )\n    parser.add_argument(\n        \"-pkv\", \"--primaryKeyValues\", help=\"primary Key Values\", nargs=\"+\"\n    )\n    parser.add_argument(\n        \"-t\",\n        \"--target\",\n        default=\"ceur-ws\",\n        help=\"wikiId of the target wiki [default: %(default)s]\",\n    )\n    parser.add_argument(\n        \"-u\", \"--update\", action=\"store_true\", help=\"update the local cache\"\n    )\n    parser.add_argument(\n        \"--topic\",\n        help=\"the topic to work with [default: %(default)s]\",\n        default=\"Scholar\",\n    )\n    parser.add_argument(\n        \"--verbose\", action=\"store_true\", help=\"show verbose edit details\"\n    )\n    parser.add_argument(\n        \"-V\", \"--version\", action=\"version\", version=Version.version_msg\n    )\n    return parser\n</code></pre>"},{"location":"#smwsync.synccmd.SyncCmd.getCachePath","title":"<code>getCachePath(cache_root=None)</code>","text":"<p>get the cache_path for the the given cache_root</p> <p>Parameters:</p> Name Type Description Default <code>cache_root(str)</code> <p>root of the cache_path - if None set to $HOME/.smwsync</p> required <p>Returns:     str: the cache path for my wikiId and context's name</p> Source code in <code>smwsync/synccmd.py</code> <pre><code>def getCachePath(self, cache_root: str = None) -&gt; str:\n    \"\"\"\n    get the cache_path for the the given cache_root\n\n    Args:\n        cache_root(str): root of the cache_path - if None set to $HOME/.smwsync\n    Returns:\n        str: the cache path for my wikiId and context's name\n    \"\"\"\n    cache_root = self.getCacheRoot(cache_root)\n    cache_path = f\"{cache_root}/{self.wikiId}/{self.context.name}\"\n    os.makedirs(cache_path, exist_ok=True)\n    return cache_path\n</code></pre>"},{"location":"#smwsync.synccmd.SyncCmd.getCacheRoot","title":"<code>getCacheRoot(cache_root=None)</code>","text":"<p>get the cache_root for the the given cache_root</p> <p>Parameters:</p> Name Type Description Default <code>cache_root(str)</code> <p>root of the cache_path - if None set to $HOME/.smwsync</p> required <p>Returns:     str: the cache root</p> Source code in <code>smwsync/synccmd.py</code> <pre><code>def getCacheRoot(self, cache_root: str = None) -&gt; str:\n    \"\"\"\n    get the cache_root for the the given cache_root\n\n    Args:\n        cache_root(str): root of the cache_path - if None set to $HOME/.smwsync\n    Returns:\n        str: the cache root\n    \"\"\"\n    if cache_root is None:\n        home = str(Path.home())\n        cache_root = f\"{home}/.smwsync\"\n    return cache_root\n</code></pre>"},{"location":"#smwsync.synccmd.SyncCmd.getMapping","title":"<code>getMapping(cache_root=None)</code>","text":"<p>get the mapping for the given cache_root</p> <p>Parameters:</p> Name Type Description Default <code>cache_root(str)</code> <p>root of the cache_path - if None set to $HOME/.smwsync</p> required Source code in <code>smwsync/synccmd.py</code> <pre><code>def getMapping(self, cache_root: str = None) -&gt; Mapping:\n    \"\"\"\n    get the mapping for the given cache_root\n\n    Args:\n        cache_root(str): root of the cache_path - if None set to $HOME/.smwsync\n    \"\"\"\n    mapping = Mapping()\n    cache_root = self.getCacheRoot(cache_root)\n    yaml_path = f\"{cache_root}/{self.context.name}_wikidata_map.yaml\"\n    mapping.fromYaml(yaml_path)\n    return mapping\n</code></pre>"},{"location":"#smwsync.synccmd.SyncCmd.getTopic","title":"<code>getTopic(topic_name)</code>","text":"<p>get the topic for the given topic name</p> <p>Parameters:</p> Name Type Description Default <code>topic_name(str)</code> <p>the name of the topic to get the properties for</p> required Source code in <code>smwsync/synccmd.py</code> <pre><code>def getTopic(self, topic_name: str):\n    \"\"\"\n    get the topic for the given topic name\n\n    Args:\n        topic_name(str): the name of the topic to get the properties for\n    \"\"\"\n    if not topic_name in self.context.topics:\n        raise Exception(\n            f\"topic {topic_name} is not in context {self.context.name} in wiki {self.wikiId}\"\n        )\n    topic = self.context.topics[topic_name]\n    return topic\n</code></pre>"},{"location":"#smwsync.synccmd.SyncCmd.getValue","title":"<code>getValue(pk, pkValue, pid)</code>","text":"<p>get the value for the given primary key and the given property id</p> Source code in <code>smwsync/synccmd.py</code> <pre><code>    def getValue(self, pk: str, pkValue: str, pid: str):\n        \"\"\"\n        get the value for the given primary key and the given property id\n        \"\"\"\n        value = None\n        if pk == \"qid\":\n            if pid == \"description\" or pid == \"label\":\n                value = None\n                try:\n                    label, description = WikidataItem.getLabelAndDescription(\n                        self.sparql, itemId=pkValue, lang=self.lang\n                    )\n                    if pid == \"description\":\n                        value = description\n                    else:\n                        value = label\n                    pass\n                except Exception as ex:\n                    # make sure we only ignore \"failed\"\n                    if not \"failed\" in str(ex):\n                        raise ex\n            else:\n                sparql_query = f\"\"\"SELECT * {{ \n  wd:{pkValue} wdt:{pid} ?value . \n}}\"\"\"\n                # see https://www.wikidata.org/wiki/Help:Ranking\n                # sparql_query=f\"\"\"SELECT ?value {{\n                #  wd:{pkValue} p:{pid} ?st .\n                #  ?st ps:P569 ?value .\n                # ?st wikibase:rank wikibase:PreferredRank\n                # }}\"\"\"\n\n                records = self.sparql.queryAsListOfDicts(sparql_query)\n                if len(records) &gt;= 1:\n                    record = records[0]\n                    value = record[\"value\"]\n                    if isinstance(value, str):\n                        value = re.sub(\n                            r\"http://www.wikidata.org/entity/(.*)\", r\"\\1\", value\n                        )\n                    else:\n                        value = str(value)\n        return value\n</code></pre>"},{"location":"#smwsync.synccmd.SyncCmd.main","title":"<code>main(args)</code>","text":"<p>command line handling</p> Source code in <code>smwsync/synccmd.py</code> <pre><code>def main(self, args):\n    \"\"\"\n    command line handling\n    \"\"\"\n    if args.about:\n        print(Version.description)\n        print(f\"see {Version.doc_url}\")\n        webbrowser.open(Version.doc_url)\n    elif args.createPropertyMap:\n        mapping = self.createMapping()\n        mapping.toYaml(args.createPropertyMap)\n    else:\n        self.mapping = self.getMapping()\n        topic = self.getTopic(topic_name=args.topic)\n        if args.proplist:\n            self.showProperties(topic=topic)\n        if args.update:\n            self.color_msg(\n                Fore.BLUE,\n                f\"updating cache for {self.context.name}:{topic.name} from wiki {self.wikiId} ...\",\n            )\n            json_path, items = self.updateItemCache(topic.name)\n            self.color_msg(\n                Fore.BLUE, f\"stored {len(items)} {topic.name} items to {json_path}\"\n            )\n        if args.props:\n            self.sync(\n                topic=topic,\n                pk=args.primaryKey,\n                pk_values=args.primaryKeyValues,\n                prop_arglist=args.props,\n            )\n</code></pre>"},{"location":"#smwsync.synccmd.SyncCmd.readItemsFromCache","title":"<code>readItemsFromCache(topic_name, cache_path=None)</code>","text":"<p>read the items back from cache</p> Source code in <code>smwsync/synccmd.py</code> <pre><code>def readItemsFromCache(self, topic_name, cache_path: str = None):\n    \"\"\"\n    read the items back from cache\n    \"\"\"\n    cache_path = self.getCachePath(cache_path)\n    json_path = f\"{cache_path}/{topic_name}.json\"\n    with open(json_path, \"r\") as json_file:\n        items = json.load(json_file)\n    return items\n</code></pre>"},{"location":"#smwsync.synccmd.SyncCmd.showProperties","title":"<code>showProperties(topic)</code>","text":"<p>show the properties for the given Topic</p> <p>Parameters:</p> Name Type Description Default <code>topic(Topic)</code> <p>the topic to show the properties for</p> required Source code in <code>smwsync/synccmd.py</code> <pre><code>def showProperties(self, topic: Topic):\n    \"\"\"\n    show the properties for the given Topic\n\n    Args:\n        topic(Topic): the topic to show the properties for\n    \"\"\"\n    if not topic.name in self.mapping.map_by_topic:\n        raise Exception(\n            f\"missing wikidata mapping for {topic.name} - you might want to add it to the yaml file for {self.context.name}\"\n        )\n    tm = self.mapping.map_by_topic[topic.name]\n    for prop_name, prop in topic.properties.items():\n        if prop_name in tm.prop_by_smw_prop:\n            pm = tm.prop_by_smw_prop[prop_name]\n            info = f\"{pm.arg}: {pm.pid_label} ({pm.pid}) \u2192 {prop.name}\"\n            print(f\"{info}\")\n        # else:\n        # info=f\"{prop_name}:{prop} \u274c - missing wikidata map entry\"\n        pass\n</code></pre>"},{"location":"#smwsync.synccmd.SyncCmd.sync","title":"<code>sync(topic, pk, pk_values, prop_arglist)</code>","text":"<p>synchronize the items for the given topic, the properties as specified by the prop_arglist the given primary key pk and the filter values pkValues</p> <p>Parameters:</p> Name Type Description Default <code>topic(Topic)</code> <p>the topic / class /entityType</p> required <code>pk(str)</code> <p>the primary key to use</p> required <code>pk_values(list)</code> <p>a list of primaryKeyValues to filter for</p> required <code>prop_arglist(list)</code> <p>the argument names for properties to be handled</p> required Source code in <code>smwsync/synccmd.py</code> <pre><code>def sync(self, topic: Topic, pk: str, pk_values: list, prop_arglist: list):\n    \"\"\"\n    synchronize the items for the given topic, the properties as specified by the prop_arglist\n    the given primary key pk and the filter values pkValues\n\n    Args:\n        topic(Topic): the topic / class /entityType\n        pk(str): the primary key to use\n        pk_values(list): a list of primaryKeyValues to filter for\n        prop_arglist(list): the argument names for properties to be handled\n\n    \"\"\"\n    tm = self.mapping.map_by_topic[topic.name]\n    items_dict = self.readItemsFromCache(topic.name)\n    pk_map = tm.getPkSMWPropMap(pk)\n    sync_items = self.filterItems(\n        items=items_dict.values(), pk_prop=pk_map.smw_prop, pk_values=pk_values\n    )\n    self.color_msg(\n        Fore.BLUE, f\"{len(sync_items)} {tm.topic_name} items to sync ...\"\n    )\n    wikipush = WikiPush(None, self.wikiId, debug=self.debug, verbose=self.verbose)\n    if self.progress:\n        t = tqdm(total=len(prop_arglist) * len(sync_items))\n    else:\n        t = None\n    for arg in prop_arglist:\n        pm = tm.getPmForArg(arg)\n        for sync_item in sync_items:\n            pk_value = sync_item[pk_map.smw_prop]\n            wd_value = self.getValue(pk, pk_value, pm.pid)\n            if wd_value is None:\n                wd_value = \"\"\n            page_title = sync_item[tm.topic_name]\n            msg = f\"updating {page_title} {pm.smw_prop} to {wd_value} from wikidata {pk_value}\"\n            if self.verbose:\n                self.color_msg(Fore.BLUE, msg)\n            cmd = f\"\"\"wikiedit -t {self.wikiId} -p \"{page_title}\" --template {tm.topic_name} --property {pm.smw_prop} --value \"{wd_value}\" -f\"\"\"\n            if self.dry:\n                print(cmd)\n            if t is not None:\n                t.set_description(f\"{page_title}\u2192{pm.smw_prop}\")\n            wikipush.edit_wikison(\n                page_titles=[page_title],\n                entity_type_name=tm.topic_name,\n                property_name=pm.smw_prop,\n                value=wd_value,\n                force=not self.dry,\n            )\n            if t is not None:\n                t.update()\n        pass\n</code></pre>"},{"location":"#smwsync.synccmd.SyncCmd.updateItemCache","title":"<code>updateItemCache(topic_name, cache_path=None)</code>","text":"<p>update the item cache</p> <p>for the given topic name and cache_path</p> <p>Parameters:</p> Name Type Description Default <code>topic_name(str)</code> <p>the name of the topic</p> required <code>cache_path(str)</code> <p>the path to the cache - if None .smwsync in the home directory is used</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the path to the json file where the data is cached</p> Source code in <code>smwsync/synccmd.py</code> <pre><code>def updateItemCache(self, topic_name: str, cache_path: str = None) -&gt; str:\n    \"\"\"\n    update the item cache\n\n    for the given topic name and cache_path\n\n    Args:\n        topic_name(str): the name of the topic\n        cache_path(str): the path to the cache - if None .smwsync in the home directory is used\n\n    Returns:\n        str: the path to the json file where the data is cached\n\n    \"\"\"\n    topic = self.getTopic(topic_name)\n    ask_query = topic.askQuery(listLimit=5000)\n    items = self.smwAccess.smw.query(ask_query)\n    cache_path = self.getCachePath(cache_path)\n    json_path = f\"{cache_path}/{topic_name}.json\"\n    with open(json_path, \"w\", encoding=\"utf-8\") as json_file:\n        json.dump(items, json_file, ensure_ascii=False, default=str, indent=2)\n    return json_path, items\n</code></pre>"},{"location":"#smwsync.synccmd.main","title":"<code>main(argv=None)</code>","text":"<p>main program.</p> Source code in <code>smwsync/synccmd.py</code> <pre><code>def main(argv=None):  # IGNORE:C0111\n    \"\"\"main program.\"\"\"\n\n    if argv is None:\n        argv = sys.argv[1:]\n\n    try:\n        parser = SyncCmd.getArgParser()\n        args = parser.parse_args(argv)\n        if len(argv) &lt; 1:\n            parser.print_usage()\n            sys.exit(1)\n        syncCmd = SyncCmd.fromArgs(args)\n        syncCmd.main(args)\n    except KeyboardInterrupt:\n        ### handle keyboard interrupt ###\n        return 1\n    except Exception as e:\n        if DEBUG:\n            raise (e)\n        indent = len(Version.name) * \" \"\n        sys.stderr.write(Version.name + \": \" + repr(e) + \"\\n\")\n        sys.stderr.write(indent + \"  for help use --help\")\n        if args.debug:\n            print(traceback.format_exc())\n        return 2\n</code></pre>"},{"location":"#smwsync.version","title":"<code>version</code>","text":"<p>Created on 2022-09-11</p> <p>@author: wf</p>"},{"location":"#smwsync.version.Version","title":"<code>Version</code>","text":"<p>               Bases: <code>object</code></p> <p>Version handling for pySMWSync</p> Source code in <code>smwsync/version.py</code> <pre><code>class Version(object):\n    \"\"\"\n    Version handling for pySMWSync\n    \"\"\"\n\n    name = \"pySMWSync\"\n    version = smwsync.__version__\n    date = \"2023-03-03\"\n    updated = \"2024-03-19\"\n    description = \"python library to synchronize property values of a semantic MediaWiki with e.g. wikidata or another Semantic MediaWiki\"\n\n    authors = \"Wolfgang Fahl\"\n\n    doc_url = \"https://wiki.bitplan.com/index.php/pySMWSync\"\n    chat_url = \"https://github.com/WolfgangFahl/pySMWSync/discussions\"\n    cm_url = \"https://github.com/WolfgangFahl/pySMWSync\"\n    version_msg = f\"v{version},{updated}\"\n    full_description = f\"{name} - {description}({version_msg})\"\n\n    license = f\"\"\"Copyright 2023 contributors. All rights reserved.\n\n  Licensed under the Apache License 2.0\n  http://www.apache.org/licenses/LICENSE-2.0\n\n  Distributed on an \"AS IS\" basis without warranties\n  or conditions of any kind, either express or implied.\"\"\"\n    longDescription = f\"\"\"{name} version {version}\n{description}\n\n  Created by {authors} on {date} last updated {updated}\"\"\"\n</code></pre>"}]}